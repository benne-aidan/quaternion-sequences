# Description

**NOTE:** This README is a work in progress.

This repository will contain various approaches and algorithms to find specific quaternion sequences
The python folder contains python code, and the rust folder contains rust code.
The cpp folder contains Curtis Bright's implementation of a Williamson sequences search.

The algorithm to find Perfect Quaternion Sequences is written in rust, and is accessible through shell scripts.

## How to run

In order to run it, one must first compile the code once using the command:
`cargo build --release`

This will create an exectuable in the target folder, which the driver scripts use.

### Driver scripts

* `driver.sh` runs the main algorithm as described in our paper to exhaustively generate sequences of the desired length. Results wlil be stored in /rust/results/pairs/`<sequencetype>`/find_`<length>`/  
Usage: `./driver.sh <sequencetype> <length> [flags]`
    * `sequencetype` is the type of sequence to be searched for. Options are either qts, wts, or ws
    * `length` is the length 
    * Flags:
        * `-d`: Delete existing .seq, .pair and .sorted files before running
        * `-h`: Convert sequences to Hadamard matrices when finished
        * `-c`: Use auto/cross correlation for matching instead of PSD/CPSD
        * `-s`: Use this flag for SLURM jobs
        * `-p <pairing>`: Specify rowsum pairing to be used. Options include WX, WY and WZ (e.g., WX means that the sequences of rowsum W are paired with the sequences of rowsum X). Note that the code follows the convention W <= X <= Y <= Z. Default is WZ  
* `driver_unomptimized.sh` is exactly the same as `driver.sh`, except it runs an unoptimized version of the code with extra checks turned on to verify correctness.
* `collect_results.py` generates a summary of a completed computation in a table. Run with no arguments to see required parameters. **NOTE:** If sequences have not been reduced to Hadamard equivalence, the corresponding part of the table will be recorded as -1.
* `pair_file_cleanup.sh` removes the `.pair` (and related) files from the `/find_n` directories. These can take up a lot of disk space for large lengths.
* `verify_qts_wts.sh` verifies that all recorded QTS for a given length are also WTS, which is conjectured to always be the case in our paper.


The different parts of the algorithm run by `driver.sh` can also be run one at a time via the following scripts, which must be run in the following order:
1. `pairs.sh` generates all of the `.pair` files
2. `sortpairs.sh` sorts the `.pair` files
3. `join_pairs.sh` matches the data in the `.pair` files to find valid sequences, and reduces them to sequence equivalence
4. `convert.sh` converts the matched sequences found in the previous step to Hadamard matrices up to Hadamard equivalence

All scripts can be run without arguments to get a message describing how to use them.

### Output files
Any and all output generated by these scripts that is not written to `stdout` is written to the following files in `/rust/results/pairs/sequencetype/find_n/`:
* `result.log` contains the output log from a computation, which mostly mirrors the output sent to `stdout`
* `result.mat` contains any generated Hadamard matrices
* `result.seq` contains the final generated sequences up to equivalence in the form of quaternion sequences according to our [encoding](#quaternion-encoding)
* `result.qseq` contains the final generated sequences up to equivalence in the form of quadruples of binary sequences
* `ns_canonical.seq` is a list of generated sequences filtered only by the NS operation. These are saved when they are computed during the sequence equivalence reduction, and later reused by the Hadamard equivalence reduction
* `rowsum_w_x_y_z/` contains the exhaustive enumeration of binary sequences to match the rowsums $(w,x,y,z)$, as well as the `.pair` files

## How to continue this project

This project has been started with a specific goal in mind, but there are a lot of things that can be improved and build upon.

### Algorithm to find other types of sequences

One of the main continuations would be extend this algorithm to other types of sequences given in Barrera Acevedo and Dietrich's paper.
The functions should be extendable simply by passing as a parameter the type of the sequence we're considering, and adding the distinction in the computed values.

### Improvements if WTS = QTS

If WTS are the same as QTS, then we can eliminate all the sequences whose cross-correlation isn't symmetric.
This would cut out a lot of sequences and improve the algorithm a lot.


# Layout of the code

## In the rust folder:

As mentioned earlier, the `rust` folder contains the implementation for the algorithm described in our paper.

### The src folder contains all of the code 

The find folder contains the code that finds and generates specific sequences

The sequences folder contains the code for the classes related to Quaternion or Williamson sequences.

The test folder contains tests of various parts of the code.
You can run the tests with the command `cargo test`.

### Quaternion encoding

The Quaternion and Williamson sequences are stocked in the following format:
each line contains a sequence, and each element correspond to a character:

| Quaternion | Encoding |
| :--------: | :------: |
| $1$        | `+`      |
| $-1$       | `-`      |
| $i$        | `i`      |
| $j$        | `j`      |
| $k$        | `k`      |
| $q$        | `q`      |
| $qi$       | `x`      |
| $qj$       | `y`      |
| $qk$       | `z`      |

with $q=\frac{1+i+j+k}{2}$

The negatives of these quaternions (except $1$ and $-1$) are stocked as the capital letter representing the quaternion.
For example, $-qi \rightarrow$ `X`

### The src/find folder

This folder contains all the code that can find sequences.

`find_naive`, `find_optim`, `find_unique` and `find_williamson` are all variations of the naive approach: bruteforcing the sequences

`find_with_rowsum` is an approach using a solver that failed and was too slow for what we were aiming for

`find_write` contains the code of the efficient algorithm that we explain in our paper. 


## In the python folder


## In the cpp folder
