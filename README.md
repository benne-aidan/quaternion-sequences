# Description

This repository will contain various approaches and algorithms to find specific quaternion sequences
The python folder contains python code, and the rust folder contains rust code.
The cpp folder contains Curtis Bright's implementation of a Williamson sequences search.

## The current state of the code

The algorithm to find Perfect Quaternion Sequences is written in rust.

### How to run

In order to run it, one must first compile the code once using the command:
`cargo build --release`

This will create an exectuable in the target folder, which the driver script uses.

To compute for Quaternion-type sequences of length n, the you can run the script:
`./driver.sh n`

This will generate multiple files in the folder:
results/pairs/wts/find_n

### The generated files

Some are temporary, and the final files are called "result.*"

result.log collects data from the driver and tracks multiple parameters for debug purposes.

result.seq collects the sequences that have been found up to Sequence equivalence.


### `driver.sh`
This is the main driver. This script creates the relevant files (`result.xyz`, etc.), and then calls the main rust program using `./target/release/rust pairs $n $rowsum_pairing`. The parameters are as follows:
* The `pairs` argument runs the first and longest part of the algorithm, from generating possible rowsums to generating the `.pair` files containing the auto and cross correlation values for the pairs
* `n` is the length of sequence to be searched for
* `rowsum_pairing` can take a value of either `XY`, `XZ`, or `XW`. It decides which groups of sequences to pair together based on their rowsums.

The `.pair` files are then sorted into `.sorted` files using `sortpairs.sh`, which is just a script to run a bash sort in a SLURM job. The rust code is then run again with `./target/release/rust join $n`, to finish the algorithm by going through the sorted auto and cross correlation values to find valid QTS, and then compute the corresponding PQS.

### The other scripts

Once the driver has been launched and the the sequences are generated, there are also other scripts that can generate useful information about the sequences:

* `job_convert.sh` will convert the sequences to Hadamard Matrices and give you the number of Hadamard Matrices made from QTS up to Hadamard equivalence
* `countpairs.sh` will give you the number of pairs that the algorithm generated given a length n
* `driver_parallel.sh` will launch DRAC jobs in parallel, computing each pair of each rowsum individually


There are also additional scripts that run only part of the driver, in case this one fails during one of the parts:


* `job_sort.sh`, `job_sort_simple.sh`, `job_sort_specific.sh`, `sortpairs.sh` are all variants of the sorting part of the algorithm
* `job_join.sh` runs the last part of the driver, once the files are sorted


And finally a few scripts to start batches on the Digital Research Alliance of Canada's computers

* `start_pairs_batches.sh` launches batches in parallel for each rowsum possible
* `start_sort_batches.sh` launches batches in parallel for the sorting part of the algorithm



## How to continue this project

This project has been started with a specific goal in mind, but there are a lot of things that can be improved and build upon.

### Algorithm to find other types of sequences

One of the main continuations would be extend this algorithm to other types of sequences given in Barrera Acevedo and Dietrich's paper.
The functions should be extendable simply by passing as a parameter the type of the sequence we're considering, and adding the distinction in the computed values.


### Additional Scripts

One useful script to add would be a script that generates the data for one line of the sequence.
Most of it can be found in the result.log file, but there are also other resources that are tracked:
- the memory usage
- the number of pairs generated by the algorithm (data given by countpairs.sh)

There could be a script that generates all the sequences from the result.seq file
This would use the function "..." in ...

### Improvements if WTS = QTS

If WTS are the same as QTS, then we can eliminate all the sequences whose cross-correlation isn't symmetric.
This would cut out a lot of sequences and improve the algorithm a lot.


# Description of the folders

## In the rust folder:

### The scripts




### The src folder contains all of the code 

The main details what part of the code is running. You can change that by changing which function of the file it is running.
You can run the code with the command 'cargo run'

The find folder contains the code that finds and generates specific sequences

the sequences folder contains the code for the classes related to Quaternion or Williamson sequences.

The test folder contains tests of various parts of the code.
You can run the tests with the command 'cargo test'




### The results folder contains all the data generated by the code.

The results folder has multiple folders corresponding to the different types of sequences the search has produced.
Here's what each of them stand for:
pqs     -> perfect quaternion sequence
ws      -> Williamson sequence
wts     -> Williamson-type sequence


The i.seq files contain a list of all the sequences of the specified type, of length i, starting with a 1.
The i.log contains information about the performances of the program when computing the i.seq file.


The Quaternion and Williamson sequences are stocked in the following format:
each line contains a sequence, and each element correspond to a character:
1       -> +
-1      -> -
i       -> i
j       -> j
k       -> k
q       -> q
qi     -> x
qj     -> y
qk     -> z

with q = (1+i+j+k)/2

The negatives of these quaternions (except 1 and -1) are stocked as the capital letter representing the quaternion.
For example, -qi -> X

### The src/find folder

This folder contains all the code that can find sequences.

find_naive, find_optim, find_unique and find_williamson are all variations of the naive approach: bruteforcing the sequences

find_with_rowsum is an approach using a solver that failed and was too slow for what we were aiming for

find_write contains the code of the efficient algorithm that we explain in our paper.


## In the python folder


## In the cpp folder
